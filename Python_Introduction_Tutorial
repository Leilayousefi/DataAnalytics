Part 2, Task cont
Let's import the pandas package for later use. We can do this with the import statement.

In Jupyter, we can run all the code in a "cell" (a block of code) by hitting shift and return.

Run the cell below to import the pandas package. The as statement allows us to refer to pandas with an alias making our code later on a little easier to read (and type).

import pandas as pd
## Part 3: General Python concepts
​
We'll return to using the `pandas` package for data analysis later. But it is worth taking a step back and going over a few basics of python.
​
### Data Types: floats, ints and strings
​
In Python, there are about a dozen or so built in data types. We won't cover them all right now, but there are a few that are useful to know.
​
Firstly we'll compare numeric and text type. The two key numeric data types are `float` and `int` (integer). To see how these differ let's look at the cells below.
# we can assign a value to a variable with =
a = 1.2
b = 2.9
​
# both of the values above are currently floats. Try running this cell to return the result of the sum below
print(a + b)
We can turn a and b into integers by wrapping the value in int() e.g. int(3.8).

Task: in the cell above, make a and b integers and see what the result is.

Solution

Text data types are called strings. You can assign a string by wrapping it in quotes (e.g. "Python").

Task: in the cell below, assign string1 to "Hello" and string2 to "world".

Solution

string1 = ""
string2 = ""
​
print(string1 + ", " + string2)
Task: in the cell below, change the values of a and b to strings to see how the result of the sum changes

Solution

a = 1
b = 2
​
print(a + b)
Data Types: Lists
A list is a type of sequence, allowing us to store multiple values. Lists look like this: [1, 2, "a_string", 3.8]. As you can see in the example, lists can store values with different data types.

We'll also introduce another concept here, the for loop. This allows us to loop through each value in a list and do something to it. To add a value to a list you can use the method, append (e.g a_list.append(1)).

Task: in the cell below, replace print(value) to instead append two times each value in my_list to my_new_list (hint the multiply operator in python is *)

Solution

my_list = [1, 2, 3, 4, 5]
my_new_list = []
for value in my_list:
    print(value)
    
print(my_new_list)
You'll notice that everything inside the for loop is indented. Indentation is a way of telling the python interpreter that the group of statements belongs to a particular block of code. This is a key part of python. If you are used to other langauages such as R, you'll be familiar with brackets being used for this purpose instead.

We can access a single value or several values of a list by using its index. An important aspect of python to remember is that its index starts at zero. We therefore access the first value of a list as a_list[0].

Task change the code below to access the third value of the list.

We can take a slice (multiple values) of a list using the notation a_list[m:n]: starting with postion m and up to but not including n (e.g a_list[0:2] to return the first two values).

Task change the code below to access the 3rd to 5th values of the list.

Solution
my_list = ["hello", 20, 30, 40, 52.9]
print(my_list[0])
You can also specify only m or n to have an open-ended selection, e.g. a_list[2:] to return all values after the second or a_list[:2] to return the first two values.

A negative index returns a value counting from the end of the list, rather than the start. So a_list[-1] is the last value, a_list[-2] the second-to-last value and so on.

Task: change the code below to access the last three values of the list.

Solution
my_list = ["Antwerp", 72, 0, -813.4, "woodpecker", "sandwich", 17.8, 1, 1, 19, "reptilian", 2]
print(my_list[0])
Data Types: Dictionaries
A dictionary is a different type of sequence. Dictionaries store values indexed by a key, rather than by their order in the sequence. They are designated by curly brackets, for example: legs = {"dragon": 4, "wyvern": 2, "serpent": 0, "millipede": "lots"}. In this example "dragon", "wyvern", "serpent" and "millipede"are the keys, and 4, 2, 0 and "lots" are the respective values.

Values in a dictionary may be accessed using square brackets, for example legs["millipede"] would return "lots". New values may be added by assigning them to a new key, for example legs["spider"] = 8.

Task: in the cell below, before print(creature) add a line to add a new key "limbs" to each of the dictionaries, being the sum of the other values.

Solution

dragon = {"legs": 4, "arms": 0, "wings": 2, "tails": 1}
human = {"legs": 2, "arms": 2, "wings": 0, "tails": 0}
dragonfly = {"legs": 6, "arms": 0, "wings": 4, "tails": 0}
for creature in [dragon, human, dragonfly]:
    print(creature)
Data Types: bool
Another data type in python is the bool (Boolean). This can only take two values, True or False (note here the case: in python case matters, so True is different from true or TRUE).

We'll introduce a related concept here: the if statement, which we'll discuss more later.

Task: Change my_bool to True to get the print statement to execute.

Solution

my_bool = False
if my_bool is True:
    print(f"Yes, my bool is {my_bool}")
We've sneakily introduced another useful feature of python here: the f-string. This allows you to insert a value easily into a string. To achieve this we prefix our string with an f and use curly brackets to add any variables you have pre-assigned.

There are other data types which you may come across but we'll move on for now.

Operators and logical conditions
We introduced the concept of an if statement earlier. As well as is and a couple more special operators, python supports the conditions listed below:

Equals: a == b
Not Equals: a != b
Less than: a < b
Less than or equal to: a <= b
Greater than: a > b
Greater than or equal to: a >= b
These can be introduced to an if statement like:

if a == b:
    print("a is equal to b!")
Task: in the cell below, use a for loop, an if statement and an f-string to check if each value in the list is greater than 5, and if it is, print a string saying what the value is and that it is greater than 5.

Solution

my_list = [5, 2, 7, 9, 1]
for value in my_list:
    ...
You can also use the conditions and (true if both of the conditions either side of it are true), or (true if at least one of the conditions either side of it are true) and not (true if the condition after it is false) to build more complicated conditions Regular brackets ( and ) can be used to group conditions to control the order in which they are evaluated.

Another very useful condition is in to test whether something is present in a list. a in b returns true only if the list b contains the value a. not in does exactly the opposite.

Task: in the cell below, use a for loop and a single if statement to print the letters which appear in string a but not in b. Note that characters in a string work just like values in a list.

Solution

a = "violin"
b = "vandal"
for character in "abcdefghijklmnopqrstuvwxyz":
    ...
Functions
A function is a group of related statements that perform a specific task. Functions can take input value(s) and they can return value(s).

Variables that are declared within a function cannot be accessed outside the function (they are "local" to the function). They are useful for breaking code into smaller, modular chunks.

You can define a function with the keyword def. The example below takes in a value, multiplies it by 4 and subtracts 3, and returns the value.

Task: change the function below to only subtract 3 if x * 4 is greater than 30.

Task: now change the function to multiply x by a second argument/value, y, rather than by 4 (might take a little bit of googling).

Solution

def my_function(x):
    new_number = x * 4 - 3
    return new_number
​
z = my_function(7)
print(z)
Part 4: Pandas and S3
Note: To complete this part of the training, you will need access to the alpha-everyone S3 bucket. To gain this access, add your username to this file by clicking the pen in the top right corner, and following instructions from there to create a pull request. For help, you can ask in the #ask-data-engineering slack channel.

We imported pandas earlier. Pandas is a data analysis package that you will likely work with a lot if you use python. Pandas stores tabular data in a object called a DataFrame. If you have used R before, this is a concept you will be familiar with. Either way, we will learn about how to manipulate data in DataFrames below.

Reading a CSV from S3
Pandas offers a simple solution to reading in files from the Analytical Platform's storage area, AWS S3. We can read in a CSV, JSON or Parquet file with a single line of code, after installing the s3fs package.

pd.read_csv("path_to_file_in_s3")
pd.read_json("path_to_file_in_s3")
pd.read_parquet("path_to_file_in_s3")
Task: install the s3fs package to access data from s3

Task: Alter the code below to read in the file "s3://alpha-everyone/python_training/courts_data.json"

Solution

df = pd.read_json("")
df.head()
The .head() method allows us to view just the first 5 rows of the DataFrame. You can view more by adding in the number of rows as an argument (e.g df.head(8)). We see that the file contains details on a selection of courts, including their location and their type(s).

Summarising and manipulating data in pandas
Pandas provides some built in functions for summarising and manipulating data.

The .describe() method will give basic statistics on all numeric columns in a dataframe as shown if you run the cell below. However, we might want to just look at a single column, and perhaps we are only interested in one statistic. To reference a column, we use square brackets and the name of the column (df["column_name"]). We can apply a variety of different methods to a column, including (but certainly not limited to!): .mean(), .min(), .max() and .median()

Task: Change the code below to find the latitude of the northen-most court

Solution

df.describe()
That's great, but this doesn't actually show us which court it is. We might find a different method useful for this. We can try sorting the entire dataframe. For this we can use .sort_values(by=column_name, ascending=True/False).

Task: In the cell below, sort the dataframe, df, by western-most court to eastern-most court.

Solution

df.head()
The column court_types tells us what type of court it is, however, a court can have more than one type. At the moment, the column contains a list. For the next task we are going to want to filter the dataframe to only contain family courts. But we'll want to do a bit of manipulation first to make that happen. We'll want to create a row for each entry in the court type list. To do this we can use explode(). Pandas has good documentation with examples you can use to understand how to use it, see here.

We can also filter a dataframe on a column using the notation df[df["column_name"] == value].

Task: In the cell below, alter the code to filter the dataframe df to only show "Family Court"s.

Note that up until now, we haven't been permanently altering the dataframe with our code. To retain our exploded dataframe we'll need to assign a new dataframe (with the same name) using df = df....

Solution

df = df...
df[]
Now we'll try one final few harder tasks. We want to figure out how far each court is in km from 102 Petty France. For this we'll need a function to calculate distance using latitude and longitude, and we'll need to apply that function to each row in the dataframe.

Task: Using the answer to this stack overflow question (https://stackoverflow.com/a/19412565), produce a function that takes in four arguments: latitude of point 1, longitude of point 1, latitude of point 2, longitude of point 2; and returns distance between the coordinates in km. Code has been started for you below.

Solution

from math import sin, cos, sqrt, atan2, radians
​
def distance_between_coordinates(lat1, lon1, lat2, lon2):
    
    return distance
​
​
# to test your function you can run the code below 
# which should show the distance between
# 10 South Colonnade and 102 Petty France
distance_between_coordinates(51.504444, -0.021389, 51.500516, -0.133192)
To apply this function to every row in the dataframe, we'll need to use apply(). To apply a function with a single argument to a column we'd do: df["new_column"] = df["column_name"].apply(my_function()). However, our function takes in four arguments so we'll need to do something a bit more complex. This stack overflow article explains quite nicely how to do it: https://stackoverflow.com/a/52854800.

Task: apply your function to the latitude and longitude columns in the dataframe so get the distance to 102 Petty France for each court. Note the coordinates of 102 Petty France are 51.500516, -0.133192. Then sort the dataframe to show closest courts first. What is the closest court?

Solution

df["distance_to_location"] = ...
​

